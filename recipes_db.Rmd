---
title: "recipes"
author: "Mara Alexeev"
date: "10/8/2020"
output: html_document
---
# Part 1: Problem Definition
I love to cook. However, recipe storage is a bit complicated because recipes I use come from so many different sources: cookbooks, emails, online, note cards, printed papers, my memory! For several years, I have wanted to come up with a recipe storage system that can harmonize my recipes and also give me some functionality that is otherwise not present with many formats--scaling, changing units, etc--and that I could eventually turn into a website that I can share with family and friends or just have for myself if traveling. 

Cooking is one thing, but shopping and menu planning are actually the bigger issues for me. Making a single recipe isn't that difficult, but when you start planning a week's worth of cooking or a multi-course meal, the pain points of collecting needed information from so many recipes becomes unwieldy (how many red onions and how many yellow onions do I need to make it through the week?!?)

I actually wrote a [blog post](https://www.maraalexeev.com/2020/04/12/recipe-storage/) about the topic back in April 2020. 

# Part 2: Requirements Gathering

## Users

I imagine my users will be myself, my husband, my brothers, and several close friends. I want it to be available for use to others beyond this circle, but with read-only capacity. 

If the database works very well, I might also offer it to a cousin who runs a resturant to see if he would find a verison for himself to be helpful. 

## Uses

1. Store recipes
2. Read recipes
3. Create menus
4. Aggregate shopping lists from selected recipes
5. Search for recipes by different characteristics
  + Ingredients (eg what's in season, what they have at home already)
  + Holiday favorites
  + Dietary restrictions (eg vegetarian, vegan)
6. Rate recipes
7. Find recipes that pair well with others

## Information Storage

1. Full instructions on how to make the recipe
2. Ingredients needed
3. Equipment needed
4. Ratings from different people over time
5. General information about ingredients
  + When they are in season
  + Where they are typically found in the grocery store
  + What form are they needed for the recipe (eg cubed, diced)

## Updates to database

I anticipate that people will frequently add to recipes to the database but that the tables themselves will not need to be frequently updated. 

## Analytic needs

Several analytic tools I have considered:

1. Looking up recipes that are suitable for guests with different dietary restrictions
2. Looking up some ones rating of a dish before making it again for them
3. Reviewing the notes of people giving ratings to see if there were suggestions for modifications or pairings
4. Making weekly meal planning simpler!
  + What recipes have common features that could allow me to minimize my time in the kitchen? (Eg making more of a particular thing that could be used in multiple meals for the week.)

# Part 3: Database Design

```{r libraries, message=FALSE, warning=FALSE}

library(tidyverse)
library(RSQLite)
library(datamodelr)
library(yaml)
library(DiagrammeR)
```

```{r}
dm <- dm_read_yaml("./recipe_db.yml")
graph <- dm_create_graph(dm, rankdir = "BT")
database_layout <- dm_render_graph(graph)
database_layout

```


# Create tibbles for all tables in database

## Metadata section

### Table: recipe_meta 

This table contains the high level information about the recipe. Every recipe should only have a single entry in this form. 

The `recipe_id` column contains an numeric id that uniquely idenitifies the recipe. The number has no sematic meaning; it is assigned as the recipe is added to the database to the next available integer value. I have considered that a recipe with important variations could be nested under the value. For example, a pasta dish could be 1 and then variations of it could be 1.1, 1.2, etc. 

The `recipe_name` is the string of text that the recipe is called that would be referred to by people in speech or likely when searching for a recipe.

The `attribution_id` is a numeric value assigned to the source of the recipe. 

The `source` is a string that specifies the location if applicable that the recipe can be found at. Examples might be a URL or a book and page number. 

The `notes` column is where text about the recipe is contained. This might be a history of where the recipe came from or what inspired it, but it does not contain the recipe itself. 

The `active_time` and `passive_time` are time durations that the recipe takes. I had initially thought that this should be stored in minutes, but some recipes have very long passive times, over days, so it might be best to store this in a format that is amenable to being converted to a human friendly display, so that if a recipe has a 3 day passive period it says 3 days not 4320 minutes.

The `estimated_servings` column has the number of servings for the basic recipe. In the shiny app I am building, this will adjust based on the scaling factor input by the user.
```{r}
recipe_meta <- tibble(
  recipe_id = 1:2,
  recipe_name = c("PBJ sandwich", "Srambled eggs"), 
  attribution_id = 1:2, 
  source = c(NA, NA),
  notes = c("Test entry", "Another test"),
  active_time = c(2, 10),
  passive_time = c(0, 2),
  estimated_servings = c(1, NA)
  )

recipe_meta 
```

### Table: menu

The `menu` table assign recipes to different menus. A recipe can be assigned many different menus and menus can have many different recipes. Examples of a menu can be a specific event, such as "Mara's 30th Birthday Party" or "New Year's Eve 2018", or to a generic event such as "Brunch" or "Picnic". 

The `recipe_id` links to the recipes and the `menu_id` will link the name of the menu in the `menu_names` table. The `menu_id` is a numeric value.

```{r}
menu <- tibble(
  recipe_id = 1:2,
  menu_id= 1:2
)

menu
```

### Table: menu_names

The `menu_names` table provides the mapping between `menu_id` and the human friendly name of the menu in `menu_name`.
```{r}
menu_names <- tibble(
  menu_id = 1:3,
  menu_name = c("Thanksgiving 2020", "New Years Eve 2019", "Birthday Brunch June 2020")
 )

menu_names
```


### Table: courses

The table `courses` contains information one what courses the recipe is likely to go well in. The `course_id` is a numeric value. A recipe might have multiple courses that it would go well in such as a side dish or as a main entree.
```{r}
courses <- tibble(
  recipe_id = 1:2,
  course_id = 1:2
)

courses
```

### Table: course_mapping

The `course_mapping` table gives the name for the `course_id`. The `course_name` is a string.
```{r}

course_mapping <- tibble(
  course_id = 1:2,
  course_name = c("side dish", "main entree")
  
)

course_mapping 
```

## Feedback section

The feedback setion of the database includes tables that have to do with people's reactions to recipes or their notes. It also contains the table with information about people in the database. 

### Table: users

The `users`table provides every user for the database with a unique numeric id called user_id. This table is also used to provide names for sources, who might not use the database, but need to be identified else where in the database. An example would be my late grandmother or Bonnie Frumkin Morales, one of my families favorite chefs whose Russian cookbook, <u>Kachka: A Return To Russian Cooking</u>, is the ground truth for modern Russian cuisine in our home.

The `name` column is the person's name stored as a string, and the `info` column are additional notes about the user stored as text. 
```{r}
users <- tibble(
  user_id = 1:6,
  name = NA,
  info = NA
)

users 
```

### Table: difficulty

The `difficulty` table is how users can rate recipes. The `recipe_meta` table has a difficulty column, and that is from me as the owner of the database. However, people can keep their own notes and reviews of recipes and use the same scale but choose a different level for the recipe. 
```{r}
difficulty <- tibble(
  difficulty_rating = 1:5,
  description = c("Very Easy", "Easy", "Moderately difficult", "Difficult", "Very Complex")
)

difficulty 
```

### Table: users_notes

The `users_notes` table allows users to store notes about recipes. This is the bug report part of the recipe database. A user can have multiple notes for a recipe. The date allows a person to capture time data about the note, the note field is text. A note can be labeled as a proxy_note with a logical value, `TRUE` or `FALSE` and then the `proxy_id` is the `user_id` of who did write the note. The use case for this is something like, I write a note for someone, say my young son, who can't write his own notes yet. This would be for ideas about how to change the recipe, or if something needed to be fixed in the recipe. 
```{r}
users_notes <- tibble(
  user_id = 1:2,
  recipe_id = 10:11,
  date = c(20201023, 20200903),
  note = c("Need to update recipe to correct mistake in step 8...", "Too much sauce to noodle ratio..."),
  proxy_note = as.logical(c(1, 0)),
  proxy_id = 3:4
)

users_notes
```

### Table: ratings

The `ratings` table is a way for users to rate recipes on and put in long text reviews. This is different from the `notes` table. The imagined case for this is collect ratings of recipes from both as an indicator of how much someone enjoyed it, to how difficult they found it to make if they cooked. The `try_again` column is a logical value if the person would try the recipe again. The required fields are `recipe_id` and at least one of `rating`, `eat_again`, or `difficulty_rating`.
```{r}
ratings <- tibble(
  recipe_id = 1:2,
  rating = 1:2,
  try_again = as.logical(c(1, 0)),
  rater_id = 1:2,
  difficulty_rating = c(1, NA),
  date = lubridate::ymd(c(20201023, 20200903)),
  notes = c("Terrible", "Would like to try with rye bread toast."),
  proxy_rating = as.logical(c(1, 0)),
  proxy_id = 3:4
)

ratings
```

### Table: rating_scale

The `rating_scale` table maps the numeric value of the `rating` to a text factor in `rating_description` that describes the numeric values's meanings. 

The `rating`  scale is a minus 2 to plus 2 scale which is highly favored in the Alexeev household. It has the benefit that the values 1 and 5 can be confused (which is the good value??), but that people are unlikely to think -2 is a good value to assign to a recipe. 

```{r}
rating_scale <- tibble(
  rating = -2:2,
  rating_description = c("Strongly disliked", "Disliked", "Indifferent", "Enjoyed", "Strongly Enjoyed")
)

rating_scale
```


## Ingredients section

### Table: ingredients_used
```{r}
ingredients_used <- tibble(
  recipe_id = 1,
  ingredient_id = 1:4,
  step_number = 1:4,
  quantity = c(2, 3, 4, 5),
  scaling_factor = 1,
  unit = as_factor(c("slices", "cups", "grams", "tablespoons")),
  preparation = as_factor(c("chopped", "diced", "sliced", "minced")),
  notes = NA
)

ingredients_used
```

### Table: ingredients_info
```{r}
ingredients_info <- tibble(
  ingredient_id = 1,
  name = "Carrot",
  season_att = as_factor("Fall"),
  category = as_factor("Vegetable"),
  store_location = as_factor("Produce"),
  ontology_info = "http://purl.obolibrary.org/obo/FOODON_00001687"
)

ingredients_info
```

## Collections section

### Table: tags
```{r}
tags <- tibble(
  recipe_id = 1:2,
  tag_id = 1:2)

tags
```

### Table: tag_names
```{r}
tag_names <- tibble(
  tag_id = 1:4,
  tag_description = as_factor(c("Christmas", "New Years", "Packed Lunch", "Baby Food"))
)

tag_names
```

## Tools and Techniques section

### Table: tools_needed 
```{r}
tools_needed <- tibble(
  recipe_id = 1,
  tool_id = 1
)

tools_needed
```

### Table: tool_info 
```{r}
tool_info <- tibble(
  tool_id = 1:2,
  name = as_factor(c("sous vide", "large pot")),
  cost = c(100, 20),
  alternative = c("water bath", NA),
  notes = NA
)

tool_info 
```

### Table: techniques_used
```{r}
techniques_used <- tibble(
  recipe_id = 1, 
  tech_id = c(1)
)

techniques_used
```


### Table: tech_info
```{r}
tech_info <- tibble(
  tech_id = 1,
  name = "Kneading", 
  notes = "As alternative can use bread setting on mixer."
)

tech_info
```

## Recipe Details section

### Table: steps
```{r}
steps <- tibble(
  recipe_id = 1,
  step_number = 1,
  directions = "Place holder"
)

steps
```

### Table: variations
```{r}
variations <- tibble(
  recipe_id = 1,
  variation_number = 1, 
  variation_text = "Instead of peanut butter try almond butter. It's worse."
)
variations
```
### Table: tips
```{r}
tips <- tibble(
  recipe_id = 1,
  tip_number = 1, 
  tip_text = "Can freeze overnight and will thaw by lunch if put in lunchbag."
)

tips
```

### Table: dietary_modifications
```{r}
dietary_modifications <- tibble(
  recipe_id = 1, 
  modification_id = 1
)

dietary_modifications
```


### Table: dietary_modifications_id
```{r}
dietary_modifications_id <- tibble(
   modification_id = 1,
   mod_id_text = "Vegan Friendly"
)

dietary_modifications_id
```

### Table: abbr_recipes
```{r}
abbr_recipes <- tibble(
  recipe_id = 1,
  step_number = 1,
  abbr_text = "Place holder on abbreviated recipe step."
)

abbr_recipes
```

### Table: raw_recipe_input
```{r}
raw_recipe_input <- tibble(
  recipe_name = "Grandma Donna's Hot Fudge Sauce",
  recipe_id = 3,
  input_text = "Place holder"
)

raw_recipe_input

write_csv(raw_recipe_input, "./csv_files/raw_recipe_input.csv")
```


# Create .db files with RSQLite
```{r}
con_recipe_db <- dbConnect(RSQLite::SQLite(), "recipesDB.db")
dbWriteTable(con_recipe_db, "recipe_meta", recipe_meta, overwrite = TRUE)
dbWriteTable(con_recipe_db, "users", users, overwrite = TRUE)
dbWriteTable(con_recipe_db, "users_notes", users_notes, overwrite = TRUE)
dbWriteTable(con_recipe_db, "difficulty", difficulty, overwrite = TRUE)
dbWriteTable(con_recipe_db, "ratings", ratings, overwrite = TRUE)
dbWriteTable(con_recipe_db, "menu", menu, overwrite = TRUE)
dbWriteTable(con_recipe_db, "menu_names", menu_names, overwrite = TRUE)
dbWriteTable(con_recipe_db, "courses", courses, overwrite = TRUE)
dbWriteTable(con_recipe_db, "course_mapping", course_mapping, overwrite = TRUE)
dbWriteTable(con_recipe_db, "steps", steps, overwrite = TRUE)
dbWriteTable(con_recipe_db, "dietary_modifications", dietary_modifications, overwrite = TRUE)
dbWriteTable(con_recipe_db, "dietary_modifications_id", dietary_modifications_id, overwrite = TRUE)
dbWriteTable(con_recipe_db, "abbr_recipes", abbr_recipes, overwrite = TRUE)
dbWriteTable(con_recipe_db, "variations", variations, overwrite = TRUE)
dbWriteTable(con_recipe_db, "tips", tips, overwrite = TRUE)
dbWriteTable(con_recipe_db, "raw_recipe_input", raw_recipe_input, overwrite = TRUE)
dbWriteTable(con_recipe_db, "tags", tags, overwrite = TRUE)
dbWriteTable(con_recipe_db, "tag_names", tag_names, overwrite = TRUE)
dbWriteTable(con_recipe_db, "tools_needed", tools_needed, overwrite = TRUE)
dbWriteTable(con_recipe_db, "tool_info", tool_info, overwrite = TRUE)
dbWriteTable(con_recipe_db, "techniques_used", techniques_used, overwrite = TRUE)
dbWriteTable(con_recipe_db, "tech_info", tech_info, overwrite = TRUE)



dbListTables(con_recipe_db)
```
# Test simple queries with RSQLite
```{r}
dbGetQuery(con_recipe_db, "SELECT * FROM recipe_meta LIMIT 10")
dbGetQuery(con_recipe_db, "SELECT * FROM variations LIMIT 10")
dbGetQuery(con_recipe_db, "SELECT * FROM tag_names LIMIT 10")
```
# Part 4: Ontologies and Terminologies

# Part 5: Analytics

## Question 1

Imagine I am feeling excited about celebrating New Years, but I am stuck in a rut of doing the same recipes for the past few years. 

### Part A

I could search the database to find ingredients that are in season around that time of the year and see if any recipes using them sound good.

### Part B

I am traveling and staying at rental house, but I am going to host a dinner for New Years. I have a restricted number of kitchen equipment, so I want to only consider recipes in my "party" tag that have the equipment i have access to. 
```{r}
# dbGetQuery(conn,"SELECT * 
#                  FROM recipes
#                  LEFT JOIN sources ON source = id_source
#                  WHERE source = 1")
```

### Question 2

My parents are coming to visit and but my vegan friend is also coming to dinner. I want to find dishes that my father has rated highly, but are also vegan friendly, so I don't have to make two separate dinners. 

# Bonus: Build it!


## Details
```{r}
sessionInfo()
```

